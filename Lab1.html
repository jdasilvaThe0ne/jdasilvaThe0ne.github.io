<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Lab 1 – Getting Started with ROS 2</title>
  <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>

  <!-- Profile (Top Left) -->
  <div class="profile">
    <img src="assets/img/me.jpeg" alt="Justino DaSilva">
    <span>Justino DaSilva</span>
  </div>

  <!-- Sidebar Navigation -->
  <nav class="sidebar">
    <h2>ROS 2 Labs</h2>
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="lab1.html">Lab 1 – Getting Started</a></li>
      <li><a href="lab2.html">Lab 2 – Core Concepts</a></li>
      <li><a href="lab3.html">Lab 3 – URDF & RViz2</a></li>
      <li><a href="lab4.html">Lab 4 – Simulation & Control</a></li>
    </ul>

    <hr>

    <ul>
      <li><a href="#why-ros">Why ROS</a></li>
      <li><a href="#setup">Setting up ROS</a></li>
      <li><a href="#concepts">Basic Concepts</a></li>
      <li><a href="#testing">Testing the Installation</a></li>
    </ul>
  </nav>

  <!-- Main Content -->
  <main class="content">

    <!-- Section 1 -->
    <section id="why-ros">
      <h2>Why Do industries use ROS</h2>

      <p>
        <strong>Why industries use ROS:</strong>
        Industries adopt ROS because it provides a standardized, modular framework
        that accelerates development and reduces cost. Instead of building
        communication layers and hardware interfaces from scratch, engineers can
        reuse proven tools and focus on application-specific intelligence.
      </p>

      <p>
        <strong>What is Middleware:</strong>
        Middleware is the software layer that allows independent components to
        communicate without needing to know each other’s internal implementation.
        In ROS 2, this role is fulfilled by DDS (Data Distribution Service), which
        enables reliable, scalable, and real-time data exchange. It  acts like a driver, creating  a
        bridge between the robots hardware coponets suchs as <b>sensors</b>
        and <b>actuators</b>  and the software. Providing a communication pipeline for data exchange  and scheduling,
        which are required  for building complex systems(robots). If a robot’s components don’t work in coordination, 
        it stops being intelligent and becomes nothing more than a piece of metal. For a conceptual overview  o ROS2 middleware interface please 
       visit <a href="https://design.ros2.org/articles/ros_middleware_interface.html">ROS2 Middleware interface</a></p>
      </p>

      <p>
        <strong>Why ROS 2 is important for real robots:</strong>
        Unlike ROS 1, ROS 2 was designed with real-world deployment in mind. It
        supports real-time execution by leveraging its Data Distribution Service, secure communication. 
        Many Robots are being largely used in industrial settings,  service industry.
        ROS2's realtime cabbilities  when used  manufacturing plants automation provide invsesters resured precise timing. 
        which is very import.  It's   independent but yet synchronized conponents (Node) makes it very useful. 
      </p>

      <p>
        <strong>Common uses of ROS:</strong>
      </p>
      <ul>
        <li>Autonomous vehicles and mobile robots</li>
        <li>Industrial robotic arms</li>
        <li>Drones and aerial robots</li>
        <li>Service and social robots</li>
        <li>Research and education platforms</li>
      </ul>
    </section>

    <!-- Section 2 -->
    <section id="setup">
      <h2>Setting up ROS</h2>

      <p>
        ROS 2 can be deployed in multiple ways depending on the user’s hardware,
        operating system, and intended use case. Each option has advantages and
        disadvantages.
      </p>

      <ul>
        <li>
          <strong>Dual Boot:</strong>
          Provides native Linux performance and full hardware access, but requires
          rebooting and disk partitioning.
        </li>
        <li>
          <strong>WSL (Windows Subsystem for Linux):</strong>
          Easy to set up on Windows and convenient for learning, but has limited
          hardware access and occasional GUI performance issues.
        </li>
        <li>
          <strong>Containers (Docker):</strong>
          Highly reproducible environments and easy dependency management, but
          require additional configuration for GUI and hardware access.
        </li>
        <li>
          <strong>Native Linux Installation:</strong>
          Best overall compatibility and performance, though it requires a full
          Linux installation.
        </li>
        <li>
          <strong>Online Interfaces:</strong>
          No installation required, but functionality is limited and unsuitable
          for advanced robotics development. For an example of an online too visit <a href="https://rosonweb.io/"">rosonweb.io</a>
        </li>
      </ul>

      <p>
        <strong>Selected approach:</strong>
        WSL is often chosen for convenience during learning and coursework, while
        native Linux is preferred for visualization, simulation, and real robot
        integration.
      </p>

      <p>
        <em>Common feedback:</em>
        “WSL is excellent for getting started quickly, but native Linux feels more
        stable and responsive for RViz2 and Gazebo.”
      </p>
    </section>

    <!-- Section 3 -->
    <section id="concepts">
      <h2>Basic ROS 2 Concepts</h2>

      <ul>
        <li><strong>Nodes:</strong> Independent executables that perform specific tasks.</li>
        <li><strong>Topics:</strong> Asynchronous communication channels using publishers and subscribers.</li>
        <li><strong>Messages:</strong> Structured data types exchanged over topics.</li>
        <li><strong>Services:</strong> Synchronous request–response interactions.</li>
        <li><strong>Actions:</strong> Long-running goals with feedback and cancellation.</li>
        <li><strong>Launch Files:</strong> Scripts that start multiple nodes together.</li>
        <li><strong>URDF:</strong> A format for describing a robot’s physical structure.</li>
      </ul>
    </section>

    <!-- Section 4 -->
    <section id="testing">
      <h2>Testing the Installation</h2>

      <p>
        After installation, ROS 2 can be tested using built-in demo nodes to verify
        communication between publishers and subscribers run the following two more commands. 
        You  should see  a similar output as depicted in the video. 
      </p>

      <pre>
ros2 run demo_nodes_py talker
ros2 topic echo /chatter
      </pre>

      <div class="video-container">
        <video controls>
            <source src="assets/videos/sub_pub.mp4" type="video/mp4">

            <!-- Captions -->
            <track src="captions.vtt" kind="subtitles" srclang="en" label="English" default>
        </video>
        </div>


      <!--p>
        The turtlesim package provides a simple graphical way to verify ROS 2
        functionality and topic-based control.
      </p-->

     

    
    </section>

  </main>

</body>
</html>
